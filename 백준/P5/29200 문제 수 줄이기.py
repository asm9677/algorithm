"""
민찬이는 KSA 학생들을 위해 1번부터  N번까지의 문제들로 구성된 문제 목록을 준비했다. i번 문제의 레벨은  Ai이다.

학생들로부터 문제가 너무 많다는 불평을 들은 민찬이는 문제 목록을 한 개 이상의 연속된 구간으로 분할해, 구간마다 그 구간에 속한 문제들을 하나의 새로운 문제로 대체하려고 한다. 단, 각 구간에는 적어도 하나의 문제가 포함되어 있어야 하며, KSA 학생들을 더 헷갈리게 하기 위해 인접한 두 구간의 문제 수는 서로 다르도록 분할해야 한다.

새로운 문제의 레벨은 해당하는 구간에 속한 문제의 레벨을 모두 bitwise XOR한 값이다. 민찬이는 KSA 학생들의 실력 향상을 위해 새로운 문제들의 레벨 합을 최대로 하려고 한다. 문제 목록을 적절한 구간들로 분할했을 때, 새로운 문제들의 레벨 합의 최댓값을 구해보자.

입력
첫 번째 줄에 정수 N이 주어진다.
두 번째 줄에 N개의 정수 A1, A2, ..., AN이 공백으로 구분되어 주어진다.

출력
새로운 문제들의 레벨 합의 최댓값을 출력한다.

예제
3
5 3 2
8

4
6 2 4 6
18

4
1 2 4 8
15
"""

"""
시간 복잡도: O(n)

A+B >= A^B 이기 때문에 각 부분 수열의 길이를 최소화 시키는 것이 유리하다.
그러나 인접한 두 구간의 길이가 서로 달라야 해야하기 때문에 이 부분에 대한 처리가 필요하다.
길이가 5인 구간의 경우 (1,4) (2,3) (3,2) (4,1)로 나눌 수 있기 때문에 인접한 구간과 길이가 항상 겹치지 않게 가능하다
길이가 6인 구간의 경우도 (1,2,3), (2,4), (4,2), (3,2,1)로 나눌 수 있기 때문에 인접한 구간과 길이가 항상 겹치지 않게 가능하다
길이가 7이상인 경우에도 왼쪽에서 길이가 1 또는 2인 구간을 때어 낼 경우 위와 같기 때문에 
길이가 4이하인 경우에 대해서만 처리를 하면된다.

dp[i][j]는 i구간 까지 부분수열의 길이가 j일 경우의 최댓값이 저장되며
dp[i][j] = max{ dp[i-k][k] |  1 <= k <= 4, k != j } 일때 
max(dp[N-1])의 값을 구하면 해결된다.
"""

import sys
input = sys.stdin.readline

N = int(input())
level = list(map(int, input().split()))

dp = [[-9876543210]*5 for i in range(N)]
dp[0][1] = level[0]

for i in range(1,N):    
    xor = 0
    for j in range(1,5):  
        if j > i+1: break 
        xor ^= level[i-j+1]                      
        dp[i][j] = (0 if i < j else max(dp[i-j][:j] + dp[i-j][j+1:])) + xor
    
print(max(dp[-1]))